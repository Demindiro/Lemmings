-- # Generic Interrupt Interface
--
-- This interface assumes a typical interrupt handling flow is:
-- 1. Interrupt is triggered
-- 2. Interrupt is claimed, disabling the interrupt.
-- 3. Interrupt is marked as completed ("End Of Interrupt" / "EOI")
--
-- For convenience, the interface presents only "blocking" methods,
-- making it easy to use from typical "synchronous" code.
door Interrupt {
	-- Wait for an interrupt to occur.
	--
	-- This routine may return immediately if the interrupt has already occurred.
	--
	-- The interrupt is automatically claimed before return,
	-- disabling this interrupt.
	wait = IrqVector -> Void
	-- Mark an interrupt as completed.
	--
	-- This re-enables the interrupt.
	done = IrqVector -> Void
	-- Reserve an interrupt vector.
	--
	-- As vectors are a limited resource,
	-- it may not always be able to allocate an unused vector.
	reserve = Void -> MaybeVector
	-- Release an interrupt vector.
	release = Vector -> Void
	-- Map an IRQ to an interrupt vector.
	map = Map -> Void
}

record Void {
}

-- An interrupt vector.
--
-- Vectors are CPU-specific.
--
-- It is expected that 4 billion vectors should be sufficient for any usecase.
u32 Vector = 0 until 0xffff_ffff
u32 NoVector = 0xffff_ffff
sum MaybeVector = Vector | NoVector

-- An interrupt request ID
--
-- IRQs are device-specific.
--
-- It is expected that 4 billion IRQs shoul be sufficient for any usecase.
u32 Irq = 0 until 0xffff_ffff

u8 Level = 0
u8 Edge = 1
sum TriggerMode = Level | Edge

-- A tuple of IRQ and Vector
--
-- Some interrupt controllers require one of either or even both,
-- hence the routines `wait` and `done` require both to be specified.
record IrqVector {
	irq = Irq
	vector = Vector
}

record Map {
	irq = Irq
	vector = Vector
	mode = TriggerMode
}
