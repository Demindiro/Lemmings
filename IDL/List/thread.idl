-- Threads support
--
-- Not all systems may be able to support threads in a reasonable manner,
-- hence a separate door is provided.
--
-- The door provides support for creating new threads,
-- parking the current thread
-- and re-scheduling parked threads.
--
-- No method is provided to abruptly stop or kill threads as this cannot be
-- done in a sane manner.
--
-- It does not support diagnoses of thread issues. This is to be provided
-- by a separate door.
door Threads {
	-- Spawn a new thread.
	--
	-- The thread will start at the given routine.
	-- A single argument can be passed.
	-- The argument should be a pointer to a data structure.
	--
	-- It was considered to allow multiple arguments to be passed,
	-- but this may rely too much on architecture details,
	-- hence it is omitted.
	spawn = Spawn -> SpawnResult

	-- Begin a critical section.
	--
	-- Any code between the start and end of this section is guaranteed
	-- to be executed atomically between all other threads who use the same
	-- mechanism and participate in the same scheduler.
	--
	-- In effect, this acts a "big global lock".
	-- Appropriate measures must be taken if contention is a concern.
	critical_section_begin = Void -> CriticalSection

	-- End a critical section.
	critical_section_end = CriticalSection -> Void

	-- Park the current thread.
	park = CriticalSection -> Void

	-- Unpark a thread.
	unpark = Thread -> Void

	-- Get a handle to the current thread.
	current = Void -> Thread
}

record Void {
}

record Spawn {
	entry = SpawnEntry
	data = MaybeSpawnDataRef
}

routine SpawnEntry = MaybeSpawnDataRef -> Void
sum MaybeSpawnDataRef = SpawnDataRef | NoSpawnDataRef
pointer SpawnDataRef = unique SpawnData
record SpawnData {
}
null NoSpawnDataRef = SpawnDataRef

u8 Ok = 0
u8 Fail = 1
sum SpawnResult = Ok | Fail

pointer Thread = shared ThreadData

record ThreadData {
}

u32 CriticalSection = 0 to 0xffff_ffff
